using System;
using System.IO;
using System.Threading;
using System.Timers;

namespace Microsoft.Exchange.Transport.Agent.Malware.SoftDelete
{
	internal class DirectoryChangeNotification : IDisposable
	{
		public DirectoryChangeNotification(CalculationAsync calculationAsysnc)
		{
			if (calculationAsysnc == null)
			{
				throw new ArgumentNullException("CalculationAsync object must be specified.");
			}
			this.calculationAsync = calculationAsysnc;
			this.directory = this.calculationAsync.SoftDeleteQueue.Storage.GetStorageDestination();
		}

		public void Dispose()
		{
			if (this.fsw != null)
			{
				this.fsw.Dispose();
				this.fsw = null;
			}
			if (this.timer != null)
			{
				this.timer.Dispose();
				this.timer = null;
			}
		}

		public void Run()
		{
			if (!Directory.Exists(this.directory))
			{
				throw new StorageException("FileWatcher cannot be installed on a directory that does not exist.");
			}
			this.fsw = new FileSystemWatcher();
			this.fsw.Path = this.directory;
			this.fsw.NotifyFilter = (NotifyFilters.FileName | NotifyFilters.Size | NotifyFilters.LastWrite | NotifyFilters.LastAccess);
			this.fsw.Filter = "*.frf";
			this.fsw.Deleted += this.OnChanged;
			this.fsw.IncludeSubdirectories = true;
			this.fsw.EnableRaisingEvents = true;
			this.timer = new System.Timers.Timer(10000.0);
			this.timer.AutoReset = false;
			this.timer.Elapsed += this.TimerElapsed;
		}

		private void OnChanged(object source, FileSystemEventArgs e)
		{
			this.timer.Enabled = true;
		}

		private void TimerElapsed(object source, ElapsedEventArgs e)
		{
			try
			{
				DirectoryChangeNotification.mutex.WaitOne();
				this.timer.Stop();
				IAsyncResult calcAsyncResult = this.calculationAsync.BeginCalculation(null, null);
				long num = this.calculationAsync.EndCalculation(calcAsyncResult);
				DirectoryStorage directoryStorage = this.calculationAsync.SoftDeleteQueue.Storage as DirectoryStorage;
				if (directoryStorage != null)
				{
					directoryStorage.CurrentDirectorySize = num;
					directoryStorage.PerfCounterWrapper.UpdateRecoveryStoreSize(num, directoryStorage.MaxThreshold, true);
				}
			}
			finally
			{
				DirectoryChangeNotification.mutex.ReleaseMutex();
			}
		}

		private static Mutex mutex = new Mutex();

		private readonly string directory;

		private CalculationAsync calculationAsync;

		private System.Timers.Timer timer;

		private FileSystemWatcher fsw;
	}
}

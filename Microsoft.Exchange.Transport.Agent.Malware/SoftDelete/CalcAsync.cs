using System;
using System.Threading;

namespace Microsoft.Exchange.Transport.Agent.Malware.SoftDelete
{
	internal class CalcAsync : IAsyncResult
	{
		public CalcAsync(AsyncCallback asyncCallback, object state)
		{
			this.asyncCallback = asyncCallback;
			this.asyncState = state;
		}

		public object AsyncState
		{
			get
			{
				return this.asyncState;
			}
		}

		public bool CompletedSynchronously
		{
			get
			{
				return Thread.VolatileRead(ref this.completedState) == 1;
			}
		}

		public WaitHandle AsyncWaitHandle
		{
			get
			{
				if (this.asyncWaitHandle == null)
				{
					lock (CalcAsync.sync)
					{
						bool isCompleted = this.IsCompleted;
						if (this.asyncWaitHandle == null)
						{
							ManualResetEvent manualResetEvent = new ManualResetEvent(isCompleted);
							this.asyncWaitHandle = manualResetEvent;
						}
						else if (!isCompleted && this.IsCompleted)
						{
							this.asyncWaitHandle.Set();
						}
					}
				}
				return this.asyncWaitHandle;
			}
		}

		public bool IsCompleted
		{
			get
			{
				return Thread.VolatileRead(ref this.completedState) != 0;
			}
		}

		public void SetAsCompleted(Exception exception, bool completedSynchronously)
		{
			this.exception = exception;
			int num = Interlocked.Exchange(ref this.completedState, completedSynchronously ? 1 : 2);
			if (num != 0)
			{
				throw new InvalidOperationException("You can set a result only once");
			}
			if (this.asyncWaitHandle != null)
			{
				this.asyncWaitHandle.Set();
			}
			if (this.asyncCallback != null)
			{
				this.asyncCallback(this);
			}
		}

		public void EndInvoke()
		{
			if (!this.IsCompleted)
			{
				this.AsyncWaitHandle.WaitOne();
				this.asyncWaitHandle.Close();
				this.asyncWaitHandle = null;
			}
			if (this.exception != null)
			{
				throw this.exception;
			}
		}

		private const int StatePending = 0;

		private const int StateCompletedSynchronously = 1;

		private const int StateCompletedAsynchronously = 2;

		private static object sync = new object();

		private readonly AsyncCallback asyncCallback;

		private readonly object asyncState;

		private int completedState;

		private ManualResetEvent asyncWaitHandle;

		private Exception exception;
	}
}

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.Exchange.Data;
using Microsoft.Exchange.Data.Directory.SystemConfiguration;
using Microsoft.Exchange.Data.Mime;
using Microsoft.Exchange.Data.Transport;
using Microsoft.Exchange.Data.Transport.Routing;
using Microsoft.Exchange.Diagnostics;
using Microsoft.Exchange.Diagnostics.Components.MalwareAgent;
using Microsoft.Exchange.Extensibility.Internal;
using Microsoft.Exchange.Transport.Agent.Malware.Actions;
using Microsoft.Exchange.Transport.Agent.Malware.Common;
using Microsoft.Exchange.Transport.Agent.Malware.SoftDelete;
using Microsoft.Filtering;
using Microsoft.Filtering.Configuration;
using Microsoft.Filtering.Results;
using Microsoft.Office.Datacenter.ActiveMonitoring;

namespace Microsoft.Exchange.Transport.Agent.Malware
{
	internal sealed class MalwareAgent : RoutingAgent
	{
		public MalwareAgent(MalwareAgentGlobal global, SmtpServer smtpServer)
		{
			this.ctx = new ScanContext();
			this.ctx.AgentGlobal = global;
			this.ctx.FilteringService = global.FilteringService;
			this.ctx.SmtpServer = smtpServer;
			this.ctx.IsInService = (DatacenterRegistry.IsForefrontForOffice() || DatacenterRegistry.IsMicrosoftHostedOnly());
			base.OnSubmittedMessage += this.OnSubmittedMessageHandler;
			this.exceptionHandler = this.CompositeExceptionHandlers(this.ctx.AgentGlobal.DefaultExceptionHandler);
			this.scanStopWatch = new Stopwatch();
		}

		internal bool IsSystemMessage(MailItem mailItem)
		{
			return mailItem.Message != null && mailItem.Message.IsSystemMessage && (this.IsJournal(mailItem) || this.IsMessageADSN(mailItem.Message.MimeDocument.RootPart.Headers) || mailItem.Message.IsPublicFolderReplicationMessage);
		}

		internal void OnSubmittedMessageHandler(SubmittedMessageEventSource source, QueuedMessageEventArgs args)
		{
			if (this.IsMailItemProcessedByMalwareAgentV2(args))
			{
				ExTraceGlobals.AgentTracer.TraceDebug((long)this.GetHashCode(), "The mailitem has already been processed by Malware Agent V2, so skipping scanning with V1.");
				return;
			}
			this.source = source;
			this.args = args;
			long mimeStreamLength = this.args.MailItem.MimeStreamLength;
			RoutingAddress fromAddress = this.args.MailItem.FromAddress;
			string messageId = this.args.MailItem.Message.MessageId;
			DateTime date = this.args.MailItem.Message.Date;
			int count = this.args.MailItem.Message.Attachments.Count;
			this.ctx.IsProbe = this.IsProbeMessage(this.args.MailItem);
			bool flag = false;
			try
			{
				SystemProbe.ActivityId = SystemProbeUtilities.GetProbeGuid(this.args.MailItem);
				SystemProbe.Trace("MalwareAgent", SystemProbe.Status.Pass, "MalwareAgent accepting message for scanning", new object[0]);
				if (this.ctx.FilteringService != null)
				{
					this.scanStopWatch.Start();
					ScanStatus scanStatus;
					if (this.IsScanRequired(args.MailItem, out scanStatus))
					{
						FilteringRequest filteringRequest;
						try
						{
							MimeFipsDataStreamFilteringRequest mimeFipsDataStreamFilteringRequest = MimeFipsDataStreamFilteringRequest.CreateInstance(args.MailItem);
							filteringRequest = mimeFipsDataStreamFilteringRequest.ToFilteringRequest(false);
							this.ctx.UsedUnifiedContent = true;
						}
						catch (ExchangeDataException)
						{
							filteringRequest = new FilteringRequest(args.MailItem.GetMimeReadStream(), messageId);
							this.ctx.UsedUnifiedContent = false;
						}
						if (!this.ctx.IsProbe)
						{
							this.ctx.FingerPrintDetails = this.ctx.AgentGlobal.FingerPrintManager.GetFingerPrint(args.MailItem.Message);
						}
						filteringRequest.Timeout = this.ctx.AgentGlobal.ServerSettings.ScanTimeout;
						filteringRequest.AbortTimeout = (int)(1.3 * (double)filteringRequest.Timeout);
						filteringRequest.SetConfiguration(this.CreateScanConfiguration(args.MailItem));
						Header header = args.MailItem.Message.RootPart.Headers.FindFirst("X-MS-Exchange-Organization-Deferred-Tracking");
						RecoveryOptions recoveryOptions = RecoveryOptions.None;
						if (header != null)
						{
							StampDefer stampDefer;
							if (StampDefer.TryParse(header.Value, (double)this.ctx.AgentGlobal.ServerSettings.DeferWaitTime, out stampDefer))
							{
								if (stampDefer.IsCrashRecoverable)
								{
									recoveryOptions |= RecoveryOptions.Crash;
								}
								if (stampDefer.IsTimeoutRecoverable)
								{
									recoveryOptions |= RecoveryOptions.Timeout;
								}
							}
							else
							{
								ExTraceGlobals.AgentTracer.TraceDebug((long)this.GetHashCode(), "Defer stamp could not be parsed.");
							}
						}
						filteringRequest.AddRecoveryOptions(recoveryOptions);
						ExTraceGlobals.AgentTracer.TraceDebug((long)this.GetHashCode(), "MalwareAgent scan is required. Begin scan request.");
						this.context = base.GetAgentAsyncContext();
						this.ctx.FilteringService.BeginScan(filteringRequest, new AsyncCallback(this.OnScanCompleted), null);
					}
					else
					{
						this.scanStopWatch.Stop();
						this.ctx.ScanStatus = scanStatus;
						this.ctx.AgentGlobal.PerfCounterWrapper.UpdateOnMalwareScan(this.ctx, this.scanStopWatch.Elapsed, this.args.MailItem.MimeStreamLength);
						SystemProbe.Trace("MalwareAgent", SystemProbe.Status.Pass, "Scan not required. Skipping scan.", new object[0]);
						ExTraceGlobals.AgentTracer.TraceDebug((long)this.GetHashCode(), "Scan not required. Skipping scan.");
						new ActionSkip().Execute(this.ctx, this.source, this.args);
						flag = true;
					}
				}
				else
				{
					new ActionDeferForever().Execute(this.ctx, this.source, this.args);
					this.ctx.AgentGlobal.PerfCounterWrapper.UpdateOnMalwareScan(this.ctx, TimeSpan.Zero, 0L);
					flag = true;
					MalwareAgentGlobal.EventLogger.LogEvent(AntimalwareEventLogConstants.Tuple_FilteringServiceNotAvailable, this.ctx.AgentGlobal.ServiceRecoveryPeriodicKey.ToString(), null);
					SystemProbe.Trace("MalwareAgent", SystemProbe.Status.Fail, "MalwareAgent filtering service is not available. Action: {0}", new object[]
					{
						this.ctx.ScanActionExecuted.ToString()
					});
					ExTraceGlobals.AgentTracer.TraceDebug((long)this.GetHashCode(), "MalwareAgent filtering service is not available.");
				}
			}
			catch (ExchangeDataException ex)
			{
				MalwareAgentGlobal.EventLogger.LogEvent(AntimalwareEventLogConstants.Tuple_MessageNotSubmittedError, null, new object[]
				{
					messageId,
					date,
					fromAddress,
					mimeStreamLength,
					ex
				});
				string errorFormat = "MalwareAgent submission error. Action: {0} Status: {1} Error: {2}";
				try
				{
					bool flag2 = false;
					this.ctx.ScanStatus = ScanStatus.Error;
					this.ctx.ErrorDetails = string.Format("{0} Error: {1}", "Submission Error: Failed to submit the message for scanning.", ex.Message);
					if (!this.HandleException(ref flag, ref flag2, ex, errorFormat, new ActionReject(false), null))
					{
						throw;
					}
					this.ctx.AgentGlobal.PerfCounterWrapper.UpdateOnMalwareScan(this.ctx, TimeSpan.Zero, 0L);
				}
				finally
				{
					this.CompleteAsyncContext();
				}
			}
			catch (Exception ex2)
			{
				bool flag3 = false;
				this.ctx.ScanStatus = ScanStatus.Error;
				MalwareAgentGlobal.EventLogger.LogEvent(AntimalwareEventLogConstants.Tuple_MessageNotSubmittedError, null, new object[]
				{
					messageId,
					date,
					fromAddress,
					mimeStreamLength,
					ex2
				});
				string errorFormat2 = "MalwareAgent submission error. Action: {0} Status: {1} Error: {2}";
				try
				{
					if (!this.HandleException(ref flag, ref flag3, ex2, errorFormat2, null, null))
					{
						throw;
					}
					this.ctx.AgentGlobal.PerfCounterWrapper.UpdateOnMalwareScan(this.ctx, TimeSpan.Zero, 0L);
				}
				finally
				{
					this.CompleteAsyncContext();
				}
			}
		}

		private static bool IsMessageBody(StreamIdentity stream)
		{
			return 0 == string.Compare("Message Body", stream.Name, StringComparison.OrdinalIgnoreCase);
		}

		private static Microsoft.Exchange.Transport.Agent.Malware.Actions.Action DetermineActionForInfectedMessage(MailItem mailItem, FilteringResults results, ScanContext context, ref ScanStatus status)
		{
			MalwareFilterPolicy malwareConfig = context.MalwareConfig;
			IEnumerable<ScanResult> enumerable = from result in results.ScanResults
			where result.Detections.Any<Detection>()
			select result;
			if (!enumerable.Any<ScanResult>())
			{
				throw new MalwareAgentTransientException("The results indicated suspected malware, but there were no detections in the scan results.");
			}
			if (context.UsedUnifiedContent)
			{
				if (!enumerable.Any((ScanResult result) => MalwareAgent.IsMessageBody(result.Stream)))
				{
					if (mailItem.Message.IsOpaqueMessage || malwareConfig.Action == MalwareFilteringAction.DeleteMessage)
					{
						return new ActionDelete();
					}
					if (malwareConfig.Action == MalwareFilteringAction.DeleteAttachmentAndUseDefaultAlertText || malwareConfig.Action == MalwareFilteringAction.DeleteAttachmentAndUseCustomAlertText)
					{
						return new ActionReplace();
					}
					throw new MalwareAgentTransientException("The malware filtering action was not recognized.");
				}
			}
			Microsoft.Exchange.Transport.Agent.Malware.Actions.Action result2 = new ActionDelete();
			status = ScanStatus.Infected;
			return result2;
		}

		private static Microsoft.Exchange.Transport.Agent.Malware.Actions.Action DetermineActionForNoDetections(ref ScanStatus status, ScanStatus slaStatus)
		{
			Microsoft.Exchange.Transport.Agent.Malware.Actions.Action result;
			if (ScanStatus.BelowPublishedSLA == (slaStatus & ScanStatus.BelowPublishedSLA))
			{
				result = new ActionDefer(typeof(ActionSoftDelete));
				status = ScanStatus.Error;
			}
			else
			{
				result = new ActionAllow();
				status = ScanStatus.Clean;
			}
			return result;
		}

		private ScanConfiguration CreateScanConfiguration(MailItem mailItem)
		{
			IList<ScannerSettings> scanners = new List<ScannerSettings>();
			bool flag = false;
			if (flag)
			{
				scanners = this.ctx.AgentGlobal.ConsumerScannerSettings;
			}
			return new ScanConfiguration
			{
				GeneralSettings = new GeneralSettings
				{
					ParseContainers = new bool?(false),
					ReturnExtractedText = new bool?(false),
					MaxNestedDepth = new ThresholdViolationAction
					{
						Threshold = new int?(2),
						ViolationAction = 0
					}
				},
				ClassificationSettings = new ClassificationSettings
				{
					IsEnabled = new bool?(false)
				},
				MalwareSettings = new MalwareSettings
				{
					IsEnabled = new bool?(true),
					StopScanningOnFirstDetection = new bool?(true),
					Scanners = scanners
				}
			};
		}

		private bool IsMailItemProcessedByMalwareAgentV2(QueuedMessageEventArgs args)
		{
			return args.MailItem.Message.RootPart.Headers.FindFirst("X-MS-Exchange-Organization-AVScannedByV2") != null;
		}

		private void OnScanCompleted(IAsyncResult ar)
		{
			ExTraceGlobals.ScanMessageTracer.TraceDebug((long)this.GetHashCode(), "Begin OnScanCompleted.");
			ScanStatus scanStatus = ScanStatus.Clean;
			if (this.context == null)
			{
				throw new InvalidOperationException("Context cannot be null if agent has gone async");
			}
			this.context.Resume();
			long mimeStreamLength = this.args.MailItem.MimeStreamLength;
			RoutingAddress fromAddress = this.args.MailItem.FromAddress;
			string messageId = this.args.MailItem.Message.MessageId;
			DateTime messageSent = this.args.MailItem.Message.Date;
			this.ctx.AttachmentCount = this.args.MailItem.Message.Attachments.Count;
			bool flag = false;
			bool flag2 = true;
			try
			{
				SystemProbe.ActivityId = SystemProbeUtilities.GetProbeGuid(this.args.MailItem);
				Microsoft.Exchange.Transport.Agent.Malware.Actions.Action action = this.exceptionHandler.DefaultAction;
				FilteringResponse filteringResponse = this.ctx.FilteringService.EndScan(ar);
				FilteringResults results = filteringResponse.Results;
				this.ctx.Results = results;
				ScanStatus scanStatus2 = this.DetermineSLAStatus(results);
				if (ResponseFlags.ContainsScanErrors(filteringResponse) && ResultsExtensions.HasPipelineError(results))
				{
					ExTraceGlobals.AgentTracer.TraceDebug((long)this.GetHashCode(), "The malware scan results contained pipeline errors.");
					scanStatus = ScanStatus.Error;
					action = new ActionDefer(typeof(ActionSoftDelete));
				}
				else if (ResponseFlags.ContainsScanErrors(filteringResponse) && ResultsExtensions.HasCategoryErrorForType(results, 3))
				{
					ExTraceGlobals.AgentTracer.TraceDebug((long)this.GetHashCode(), "The malware scan results contained category errors.");
					EventNotificationItem.Publish(ExchangeComponent.AMScanError.Name, "AntimalwareAgent.CategoryError", null, "None of the configured engines were able to scan the message successfully", ResultSeverityLevel.Error, false);
					scanStatus = ScanStatus.Error;
					if (this.ctx.AgentGlobal.ServerSettings.MinimumSuccessfulEngineScans == 0)
					{
						action = new ActionAllow();
					}
					else
					{
						action = new ActionDefer(typeof(ActionReject));
						this.ctx.OverrideWaitTime = this.ctx.AgentGlobal.OverrideWaitTime;
						this.ctx.ErrorDetails = "Category Error: All engines failed to scan the message.";
						scanStatus = ScanStatus.Error;
					}
				}
				else if (ResponseFlags.ContainsPolicyViolations(filteringResponse) && ResultsExtensions.HasCategoryPolicyViolationForType(results, 3))
				{
					ExTraceGlobals.AgentTracer.TraceDebug((long)this.GetHashCode(), "The malware scan results contained policy violations.");
					scanStatus = ScanStatus.PolicyViolation;
					this.ctx.ErrorDetails = "Error: Failed to scan the message, due to policy violation.";
					action = new ActionReject(true);
				}
				else if (ResponseFlags.ContainsDetections(filteringResponse))
				{
					ExTraceGlobals.ScanMessageTracer.TraceDebug((long)this.GetHashCode(), "The malware scan results contained detections.");
					action = MalwareAgent.DetermineActionForInfectedMessage(this.args.MailItem, results, this.ctx, ref scanStatus);
					StringBuilder stringBuilder = new StringBuilder();
					StringBuilder stringBuilder2 = new StringBuilder();
					StringBuilder stringBuilder3 = new StringBuilder();
					this.ctx.EngineResults = (this.ctx.EngineResults ?? MalwareResultLogger.Parse(this.ctx.Results));
					foreach (MalwareResultEngineInfo malwareResultEngineInfo in this.ctx.EngineResults)
					{
						stringBuilder.AppendFormat("{0},", malwareResultEngineInfo.Name);
						stringBuilder2.AppendFormat("{0},", malwareResultEngineInfo.SignatureVersion);
						stringBuilder3.AppendFormat("{0},", malwareResultEngineInfo.Detection);
					}
					MalwareAgentGlobal.EventLogger.LogEvent(AntimalwareEventLogConstants.Tuple_MalwareDetected, null, new object[]
					{
						this.args.MailItem.Message.MessageId,
						this.args.MailItem.Message.Date,
						this.args.MailItem.FromAddress,
						this.args.MailItem.MimeStreamLength,
						stringBuilder.ToString().TrimEnd(new char[]
						{
							','
						}),
						stringBuilder2.ToString().TrimEnd(new char[]
						{
							','
						}),
						stringBuilder3.ToString().TrimEnd(new char[]
						{
							','
						}),
						this.ctx.MalwareConfig.Action.ToString()
					});
					if (!this.ctx.IsProbe)
					{
						this.ctx.AgentGlobal.FingerPrintManager.AddFingerPrint(this.args.MailItem.Message, results, this.ctx.FingerPrintDetails);
					}
				}
				else if (ResponseFlags.ContainsNotificationsWithNoDetections(filteringResponse))
				{
					ExTraceGlobals.ScanMessageTracer.TraceDebug((long)this.GetHashCode(), "The malware scan results contained notifications with no detections.");
					action = MalwareAgent.DetermineActionForNoDetections(ref scanStatus, scanStatus2);
				}
				else
				{
					if (!ResponseFlags.ContainsNoDetections(filteringResponse))
					{
						throw new MalwareAgentTransientException("The result of processing the scan did not map to a corresponding handler, using default action.");
					}
					ExTraceGlobals.ScanMessageTracer.TraceDebug((long)this.GetHashCode(), "The malware scan results contained no detections.");
					action = MalwareAgent.DetermineActionForNoDetections(ref scanStatus, scanStatus2);
				}
				if (action == null)
				{
					throw new MalwareAgentTransientException("The result of processing the scan did not map to a corresponding action.");
				}
				this.UpdateComponentCost();
				this.ctx.ScanStatus = (scanStatus | scanStatus2);
				action.Execute(this.ctx, this.source, this.args);
				SystemProbe.Trace("MalwareAgent", SystemProbe.Status.Pass, "MalwareAgent processing complete. Action: {0} Status: {1}", new object[]
				{
					action.GetType().Name,
					this.ctx.ScanStatus
				});
				flag = true;
			}
			catch (StorageException e)
			{
				flag2 = false;
				MalwareAgentGlobal.EventLogger.LogEvent(AntimalwareEventLogConstants.Tuple_SoftdeleteStoreWriteError, null, new object[]
				{
					messageId
				});
				this.ctx.ScanStatus = (ScanStatus.Error | ScanStatus.StoreError);
				this.UpdateComponentCost();
				string errorFormat = "MalwareAgent failed to soft delete. New Action: {0} Status: {1} Error: {2}";
				if (!this.HandleException(ref flag, ref flag2, e, errorFormat, null, null))
				{
					throw;
				}
			}
			catch (ScanQueueTimeoutException ex)
			{
				flag2 = false;
				ScanQueueTimeoutException ex5;
				MalwareAgentGlobal.EventLogger.LogEvent(AntimalwareEventLogConstants.Tuple_ScanTimedOut, null, new object[]
				{
					messageId,
					messageSent,
					fromAddress,
					mimeStreamLength,
					0,
					ex5.GetType().Name
				});
				this.ctx.ScanStatus = (ScanStatus.Error | ScanStatus.TimedOut);
				this.scanStopWatch.Stop();
				string errorFormat2 = "MalwareAgent timeout on the scan queue. Action: {0} Status: {1} Error: {2}";
				if (!this.HandleException(ref flag, ref flag2, ex5, errorFormat2, null, null))
				{
					throw;
				}
			}
			catch (ScanTimeoutException ex2)
			{
				flag2 = false;
				MalwareAgentGlobal.EventLogger.LogEvent(AntimalwareEventLogConstants.Tuple_ScanTimedOut, null, new object[]
				{
					messageId,
					messageSent,
					fromAddress,
					mimeStreamLength,
					0,
					ex2.GetType().Name
				});
				MalwareAgentGlobal.EventLogger.LogEvent(AntimalwareEventLogConstants.Tuple_MalwareScanningError, null, new object[]
				{
					messageId,
					messageSent,
					fromAddress,
					mimeStreamLength,
					ex2
				});
				this.ctx.ScanStatus = (ScanStatus.Error | ScanStatus.TimedOut);
				this.UpdateComponentCost();
				this.ctx.IsTimeoutRecoverable = true;
				this.ctx.OverrideWaitTime = this.ctx.AgentGlobal.OverrideWaitTime;
				string errorFormat3 = "MalwareAgent timeout on scan. Action: {0} Status: {1} Error: {2}";
				this.ctx.ErrorDetails = string.Format("{0} Error: {1}", "Timeout: The message timed out repeatedly.", ex2.Message);
				if (!this.HandleException(ref flag, ref flag2, ex2, errorFormat3, null, null))
				{
					throw;
				}
			}
			catch (ScannerCrashException ex3)
			{
				flag2 = false;
				this.ctx.IsCrashRecoverable = true;
				MalwareAgentGlobal.EventLogger.LogEvent(AntimalwareEventLogConstants.Tuple_ScannerError, null, new object[]
				{
					messageId,
					messageSent,
					fromAddress,
					mimeStreamLength,
					0
				});
				MalwareAgentGlobal.EventLogger.LogEvent(AntimalwareEventLogConstants.Tuple_MalwareScanningError, null, new object[]
				{
					messageId,
					messageSent,
					fromAddress,
					mimeStreamLength,
					ex3
				});
				this.ctx.ScanStatus = (ScanStatus.Error | ScanStatus.ScannerError);
				this.UpdateComponentCost();
				string errorFormat4 = "MalwareAgent scanner error occcured for the scan. Action: {0} Status: {1} Error: {2}";
				if (!this.HandleException(ref flag, ref flag2, ex3, errorFormat4, null, null))
				{
					throw;
				}
			}
			catch (BiasException e2)
			{
				flag2 = false;
				MalwareAgentGlobal.EventLogger.LogEvent(AntimalwareEventLogConstants.Tuple_BiasNotSatisfied, null, new object[]
				{
					messageId,
					messageSent,
					fromAddress,
					mimeStreamLength,
					string.Empty,
					string.Empty
				});
				this.ctx.ScanStatus = (ScanStatus.Error | ScanStatus.BiasError);
				this.scanStopWatch.Stop();
				string errorFormat5 = "MalwareAgent bias error on scan. Action: {0} Status: {1} Error: {2}";
				if (!this.HandleException(ref flag, ref flag2, e2, errorFormat5, null, null))
				{
					throw;
				}
			}
			catch (Exception e3)
			{
				flag2 = false;
				this.ctx.ScanStatus = ScanStatus.Error;
				this.UpdateComponentCost();
				string errorFormat6 = "MalwareAgent error on scan. Action: {0} Status: {1} Error: {2}";
				if (!this.HandleException(ref flag, ref flag2, e3, errorFormat6, null, delegate(Exception ex)
				{
					MalwareAgentGlobal.EventLogger.LogEvent(AntimalwareEventLogConstants.Tuple_MalwareScanningError, null, new object[]
					{
						messageId,
						messageSent,
						fromAddress,
						mimeStreamLength,
						ex
					});
				}))
				{
					throw;
				}
			}
			finally
			{
				if (flag2)
				{
					try
					{
						if (!flag)
						{
							ExTraceGlobals.AgentTracer.TraceDebug((long)this.GetHashCode(), "Processing was not completed on this message, this message will be deferred");
							if (ScanAction.Blocked != this.ctx.ScanActionExecuted && ScanAction.Deferred != this.ctx.ScanActionExecuted && ScanAction.SoftDelete != this.ctx.ScanActionExecuted && ScanAction.Rejected != this.ctx.ScanActionExecuted)
							{
								new ActionDefer().Execute(this.ctx, this.source, this.args);
							}
						}
						this.ctx.AgentGlobal.PerfCounterWrapper.UpdateOnMalwareScan(this.ctx, this.scanStopWatch.Elapsed, mimeStreamLength);
					}
					catch (Exception ex4)
					{
						ExTraceGlobals.AgentTracer.TraceDebug<string>((long)this.GetHashCode(), "An exception was thrown when trying to update perf counters. Error : {0}", ex4.ToString());
					}
					ExTraceGlobals.AgentTracer.TraceDebug((long)this.GetHashCode(), "MalwareAgent message processing is complete.");
					SystemProbe.Trace("MalwareAgent", SystemProbe.Status.Pass, "MalwareAgent message processing is complete.", new object[0]);
				}
				this.CompleteAsyncContext();
			}
		}

		private bool HandleException(ref bool processingComplete, ref bool exceptionHandled, Exception e, string errorFormat, Microsoft.Exchange.Transport.Agent.Malware.Actions.Action action = null, Action<Exception> beforeHandledException = null)
		{
			if (!processingComplete)
			{
				exceptionHandled = ((action != null) ? this.exceptionHandler.Handle(action, e, this.ctx, this.source, this.args, beforeHandledException) : this.exceptionHandler.Handle(e, this.ctx, this.source, this.args, beforeHandledException));
			}
			return this.CompleteExceptionProcessing(ref processingComplete, ref exceptionHandled, e, errorFormat);
		}

		private bool CompleteExceptionProcessing(ref bool processingComplete, ref bool exceptionHandled, Exception e, string errorFormat)
		{
			if (!exceptionHandled)
			{
				if (this.context == null)
				{
					return false;
				}
				this.context.AsyncException = e;
			}
			else
			{
				string text = string.Format(errorFormat, this.ctx.ScanActionExecuted.ToString(), this.ctx.ScanStatus, e);
				SystemProbe.Trace("MalwareAgent", SystemProbe.Status.Fail, text, new object[0]);
				ExTraceGlobals.AgentTracer.TraceDebug((long)this.GetHashCode(), text);
				processingComplete = true;
			}
			return true;
		}

		private ExceptionHandler CompositeExceptionHandlers(ExceptionHandler defaultExceptionHandler)
		{
			return defaultExceptionHandler;
		}

		private void CompleteAsyncContext()
		{
			if (this.context != null)
			{
				this.context.Complete();
				this.context = null;
			}
		}

		private void UpdateComponentCost()
		{
			this.scanStopWatch.Stop();
			this.source.SetComponentCost("AMA", (long)this.scanStopWatch.Elapsed.TotalSeconds);
		}

		private bool IsMessageADSN(HeaderList headers)
		{
			bool result = false;
			foreach (Header header in headers)
			{
				if (string.Equals(header.Name, "X-MS-Exchange-Organization-AggregatedDsn-Report", StringComparison.OrdinalIgnoreCase))
				{
					result = true;
					break;
				}
			}
			return result;
		}

		private bool IsJournal(MailItem mailItem)
		{
			object obj = null;
			bool result;
			try
			{
				if (!mailItem.Message.MimeDocument.RootPart.ContentType.Equals("multipart/mixed", StringComparison.OrdinalIgnoreCase))
				{
					result = false;
				}
				else if (mailItem.Message.MimeDocument.RootPart.FirstChild == null || mailItem.Message.MimeDocument.RootPart.FirstChild.NextSibling == null)
				{
					result = false;
				}
				else if (mailItem.Properties.TryGetValue("Microsoft.Exchange.ContentIdentifier", out obj) && obj is string && ((string)obj).Equals("EXJournalData", StringComparison.OrdinalIgnoreCase))
				{
					result = true;
				}
				else
				{
					result = false;
				}
			}
			catch (Exception)
			{
				result = false;
			}
			return result;
		}

		private bool IsScanRequired(MailItem mailItem, out ScanStatus status)
		{
			status = ScanStatus.Error;
			if (this.IsSystemMessage(mailItem))
			{
				status = ScanStatus.BypassSystem;
				return false;
			}
			if (this.ctx.AgentGlobal.ServerSettings.BypassFiltering)
			{
				status = ScanStatus.Bypassed;
				MalwareAgentGlobal.EventLogger.LogEvent(AntimalwareEventLogConstants.Tuple_MessageBypassed, null, new object[]
				{
					mailItem.Message.MessageId,
					mailItem.Message.Date,
					mailItem.FromAddress,
					mailItem.MimeStreamLength
				});
				ExTraceGlobals.ScanMessageTracer.TraceDebug((long)this.GetHashCode(), "The malware scan is currently set to be bypassed, no scanning will take place.");
				return false;
			}
			MailDirectionality mailDirectionality = MailDirectionality.Undefined;
			TransportMailItem transportMailItem = MalwareAgentGlobal.GetTransportMailItem(mailItem);
			if (transportMailItem != null)
			{
				mailDirectionality = transportMailItem.Directionality;
			}
			this.ctx.MalwareConfig = this.ctx.AgentGlobal.GetMalwareConfig(this.source, this.args, this.ctx.SmtpServer);
			if (this.ctx.MalwareConfig.BypassInboundMessages && mailDirectionality == MailDirectionality.Incoming)
			{
				ExTraceGlobals.ScanMessageTracer.TraceDebug((long)this.GetHashCode(), "The malware scan is currently set to bypass inbound messages, no scanning will take place.");
				status = ScanStatus.Bypassed;
				return false;
			}
			if (this.ctx.MalwareConfig.BypassOutboundMessages && mailDirectionality == MailDirectionality.Originating)
			{
				ExTraceGlobals.ScanMessageTracer.TraceDebug((long)this.GetHashCode(), "The malware scan is currently set to bypass outbound messages, no scanning will take place.");
				status = ScanStatus.Bypassed;
				return false;
			}
			return this.IsMailStampMissingOrIncorrect(mailItem, out status);
		}

		private bool IsMailStampMissingOrIncorrect(MailItem mailItem, out ScanStatus status)
		{
			status = ScanStatus.Error;
			StampMalware stampMalware = StampMalware.Find(mailItem.Message.RootPart.Headers);
			if (stampMalware == null)
			{
				return true;
			}
			try
			{
				if (this.ctx.IsInService)
				{
					if (!stampMalware.IsServiceStamp)
					{
						mailItem.Message.RootPart.Headers.RemoveAll("X-MS-Exchange-Organization-AVStamp-Enterprise");
						mailItem.Message.RootPart.Headers.RemoveAll("X-MS-Exchange-Organization-AVStamp-Service");
						return true;
					}
				}
				else if (stampMalware.IsServiceStamp)
				{
					mailItem.Message.RootPart.Headers.RemoveAll("X-MS-Exchange-Organization-AVStamp-Service");
					if (this.ctx.AgentGlobal.ServerSettings.ForceRescan)
					{
						return true;
					}
					StampMalware stampMalware2 = StampMalware.Create(false);
					mailItem.Message.RootPart.Headers.AppendChild(new TextHeader(stampMalware2.Name, "1.0"));
					status = ScanStatus.BypassStamp;
					return false;
				}
			}
			catch (InvalidOperationException)
			{
				return true;
			}
			status = ScanStatus.Bypassed;
			return false;
		}

		private ScanStatus DetermineSLAStatus(FilteringResults results)
		{
			ScanStatus result = ScanStatus.Clean;
			if (this.ctx.IsInService)
			{
				foreach (ResultsExtensions.StreamResultsPair streamResultsPair in ResultsExtensions.GroupScanResultsByStream(results, 3))
				{
					List<ScanResult> list = streamResultsPair.Results.ToList<ScanResult>();
					int count = list.Count;
					int num = list.Count((ScanResult sr) => sr.ErrorInfo.HasError || sr.ErrorInfo.HasPolicyViolation);
					int num2 = count - num;
					if (num2 < 2)
					{
						if (num2 >= this.ctx.AgentGlobal.ServerSettings.MinimumSuccessfulEngineScans)
						{
							ExTraceGlobals.AgentTracer.TraceDebug<string, int>((long)this.GetHashCode(), "File {0} did not meet the internal SLA. Engine errors = {1}", streamResultsPair.Stream.Name, num);
							result = ScanStatus.BelowInternalSLA;
						}
						else
						{
							ExTraceGlobals.AgentTracer.TraceDebug<string, int>((long)this.GetHashCode(), "File {0} did not meet the published SLA. Engine errors = {1}", streamResultsPair.Stream.Name, num);
							result = ScanStatus.BelowPublishedSLA;
						}
					}
				}
			}
			return result;
		}

		private bool IsProbeMessage(MailItem mailItem)
		{
			TransportMailItem transportMailItem = MalwareAgentGlobal.GetTransportMailItem(mailItem);
			return transportMailItem != null && transportMailItem.IsProbe;
		}

		private const string ADSNSTAMPHEADER = "X-MS-Exchange-Organization-AggregatedDsn-Report";

		private const string AGENTNAME = "MalwareAgent";

		private SubmittedMessageEventSource source;

		private QueuedMessageEventArgs args;

		private AgentAsyncContext context;

		private ExceptionHandler exceptionHandler;

		private Stopwatch scanStopWatch;

		private ScanContext ctx;
	}
}

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using Microsoft.Exchange.Data.Directory.SystemConfiguration;
using Microsoft.Exchange.Data.Mime;
using Microsoft.Exchange.Data.Transport.Email;
using Microsoft.Exchange.Data.Transport.Routing;
using Microsoft.Exchange.Diagnostics.Components.MalwareAgent;
using Microsoft.Exchange.Transport.RecipientAPI;
using Microsoft.Filtering;
using Microsoft.Filtering.Results;

namespace Microsoft.Exchange.Transport.Agent.Malware.Actions
{
	internal class ActionReplace : Action
	{
		public override void Execute(ScanContext context, SubmittedMessageEventSource source, QueuedMessageEventArgs args)
		{
			ExTraceGlobals.ActionsTracer.TraceDebug((long)this.GetHashCode(), "Begin ActionReplace.Execute.");
			args.MailItem.Message.Attachments.Clear();
			string value = MalwareStrings.DefaultDeletionText;
			if (context.MalwareConfig.Action == MalwareFilteringAction.DeleteAttachmentAndUseCustomAlertText)
			{
				value = context.MalwareConfig.CustomAlertText;
			}
			else if (context.MalwareConfig.Action == MalwareFilteringAction.DeleteAttachmentAndUseDefaultAlertText)
			{
				bool flag;
				if (!((AddressBookImpl)context.SmtpServer.AddressBook).TryGetIsInternal(args.MailItem.FromAddress, out flag).Succeeded)
				{
					flag = false;
					ExTraceGlobals.ActionsTracer.TraceError<long>((long)this.GetHashCode(), "Failed to check whether the from address of mail item {0} is internal; treating as external", args.MailItem.InternalMessageId);
				}
				CultureInfo formatProvider = context.AgentGlobal.DetermineCultureBasedOnMessage(context.AgentGlobal.TransportConfiguration, args.MailItem, !flag);
				value = MalwareStrings.DefaultDeletionText.ToString(formatProvider);
			}
			Attachment attachment = null;
			try
			{
				attachment = args.MailItem.Message.Attachments.Add();
			}
			catch (InvalidOperationException)
			{
				ExTraceGlobals.AgentTracer.TraceDebug((long)this.GetHashCode(), "An opaque or system message was detected. Use delete action instead of replace.");
				new ActionDelete().Execute(context, source, args);
				return;
			}
			attachment.FileName = "Malware Alert Text.txt";
			using (Stream contentWriteStream = attachment.GetContentWriteStream())
			{
				using (StreamWriter streamWriter = new StreamWriter(contentWriteStream))
				{
					streamWriter.WriteLine(value);
					IDictionary<StreamIdentity, IEnumerable<ResultsExtensions.ScannerDetectionPair>> dictionary = ResultsExtensions.GroupDetectionsByStream(context.Results, 3);
					foreach (StreamIdentity streamIdentity in dictionary.Keys)
					{
						IEnumerable<ResultsExtensions.ScannerDetectionPair> source2 = dictionary[streamIdentity];
						if (source2.Count<ResultsExtensions.ScannerDetectionPair>() != 0)
						{
							ResultsExtensions.ScannerDetectionPair scannerDetectionPair = source2.FirstOrDefault((ResultsExtensions.ScannerDetectionPair p) => p.Scanner.Vendor.Contains("Microsoft")) ?? source2.First<ResultsExtensions.ScannerDetectionPair>();
							string name = scannerDetectionPair.Detection.Name;
							streamWriter.WriteLine(streamIdentity.Name + "\t" + name);
						}
					}
				}
			}
			StampMalware stampMalware = StampMalware.Create(context.IsInService);
			try
			{
				args.MailItem.Message.RootPart.Headers.AppendChild(new TextHeader(stampMalware.Name, "1.0"));
			}
			catch (InvalidOperationException)
			{
				ExTraceGlobals.AgentTracer.TraceDebug((long)this.GetHashCode(), "Failed to add the malware stamp in ActionReplace.");
			}
			base.SendSenderNotifications(context, args, ScanAction.Replaced);
			context.ScanActionExecuted = ScanAction.Replaced;
			base.TrackMalwareAgentInfo(context, source);
		}
	}
}

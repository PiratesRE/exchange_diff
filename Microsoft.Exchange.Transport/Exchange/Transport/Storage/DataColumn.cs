using System;
using System.Globalization;
using System.IO;
using Microsoft.Exchange.Data;
using Microsoft.Exchange.Net;
using Microsoft.Isam.Esent.Interop;

namespace Microsoft.Exchange.Transport.Storage
{
	internal abstract class DataColumn
	{
		protected DataColumn(JET_coltyp type, bool fixedSize)
		{
			this.type = type;
			this.fixedSize = fixedSize;
		}

		protected DataColumn(JET_coltyp type, bool fixedSize, int size)
		{
			this.type = type;
			this.fixedSize = fixedSize;
			this.columnSize = size;
		}

		private DataColumn()
		{
		}

		public string Name
		{
			get
			{
				return this.name;
			}
			set
			{
				if (string.IsNullOrEmpty(value))
				{
					throw new ArgumentException(Strings.ColumnName, "value");
				}
				this.name = value;
			}
		}

		public bool Required
		{
			get
			{
				return this.required;
			}
			set
			{
				this.required = value;
			}
		}

		public JET_COLUMNID ColumnId
		{
			get
			{
				return this.columnId;
			}
			set
			{
				this.columnId = value;
			}
		}

		public bool Cached
		{
			get
			{
				return this.cached;
			}
			set
			{
				this.cached = value;
			}
		}

		public int CacheIndex
		{
			get
			{
				return this.cacheIndex;
			}
			set
			{
				this.cacheIndex = value;
			}
		}

		public bool MultiValued
		{
			get
			{
				return this.multiValued;
			}
			set
			{
				this.multiValued = value;
			}
		}

		internal bool Fixed
		{
			get
			{
				return this.fixedSize;
			}
		}

		internal bool AutoIncrement
		{
			get
			{
				return this.autoIncremented;
			}
			set
			{
				this.autoIncremented = value;
			}
		}

		internal bool IntrinsicLV
		{
			get
			{
				return this.intrinsicLV;
			}
			set
			{
				this.intrinsicLV = value;
			}
		}

		internal bool AutoVersioned
		{
			get
			{
				return this.autoVersioned;
			}
			set
			{
				this.autoVersioned = value;
			}
		}

		internal bool IsAutoGenerated
		{
			get
			{
				return this.AutoIncrement || this.AutoVersioned;
			}
		}

		internal JET_coltyp JetColType
		{
			get
			{
				return this.type;
			}
		}

		public static DataColumn CreateInstance(Type typeInfo)
		{
			if (typeInfo == typeof(int))
			{
				return new DataColumn<int>(JET_coltyp.Long, true);
			}
			if (typeInfo == typeof(long))
			{
				return new DataColumn<long>((JET_coltyp)15, true);
			}
			if (typeInfo == typeof(byte))
			{
				return new DataColumn<byte>(JET_coltyp.UnsignedByte, true);
			}
			if (typeInfo == typeof(bool))
			{
				return new DataColumn<bool>(JET_coltyp.Bit, true);
			}
			if (typeInfo == typeof(string))
			{
				return new DataColumnString(JET_coltyp.LongText, false);
			}
			if (typeInfo == typeof(byte[]))
			{
				return new DataColumnByteArray(JET_coltyp.LongBinary, false);
			}
			if (typeInfo == typeof(Guid))
			{
				return new DataColumn<Guid>((JET_coltyp)16, false);
			}
			if (typeInfo == typeof(DateTime))
			{
				return new DataColumn<DateTime>(JET_coltyp.DateTime, false);
			}
			if (typeInfo == typeof(IPvxAddress))
			{
				return new DataColumn<IPvxAddress>(JET_coltyp.Binary, true, 16);
			}
			throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture, "DataColumn.CreateInstance(): Type '{0}' not supported", new object[]
			{
				typeInfo.FullName
			}));
		}

		public static void ReopenAsLazyReader(Stream stream)
		{
			CachingStream cachingStream = stream as CachingStream;
			if (cachingStream == null)
			{
				throw new ArgumentException(Strings.IncorrectBaseStream);
			}
			if (cachingStream.InMemory)
			{
				cachingStream.ReleaseDatabase();
				return;
			}
			cachingStream.ReOpenForRead();
		}

		public JET_COLUMNDEF MakeColumnDef()
		{
			JET_COLUMNDEF jet_COLUMNDEF = new JET_COLUMNDEF();
			jet_COLUMNDEF.cp = JET_CP.Unicode;
			jet_COLUMNDEF.cbMax = this.columnSize;
			jet_COLUMNDEF.coltyp = this.JetColType;
			if (this.autoIncremented)
			{
				jet_COLUMNDEF.grbit = ColumndefGrbit.ColumnAutoincrement;
			}
			else if (this.autoVersioned)
			{
				jet_COLUMNDEF.grbit = ColumndefGrbit.ColumnVersion;
			}
			else
			{
				jet_COLUMNDEF.grbit = ((this.Required ? ColumndefGrbit.ColumnNotNULL : (ColumndefGrbit.ColumnTagged | ColumndefGrbit.ColumnMaybeNull)) | ((this.Fixed & this.Required) ? ColumndefGrbit.ColumnFixed : ColumndefGrbit.None) | (this.MultiValued ? ColumndefGrbit.ColumnMultiValued : ColumndefGrbit.None));
				if (this.type == JET_coltyp.LongText || this.type == JET_coltyp.LongBinary)
				{
					jet_COLUMNDEF.grbit |= (ColumndefGrbit)524288;
				}
			}
			return jet_COLUMNDEF;
		}

		public Stream OpenImmediateReader(DataTableCursor cursor, DataRow row, int sequence = 1)
		{
			return new DataStreamImmediateReader(this, cursor, row, sequence);
		}

		public Stream OpenLazyReader(DataTableCursor cursor, DataRow row, int sequence = 1)
		{
			Stream parentStream = new DataStreamLazyReader(this, cursor, row, sequence);
			return new BufferedStream(parentStream, DataStream.BufferedStreamSize);
		}

		public Stream OpenCachingWriter(DataTableCursor cursor, DataRow dataRow, bool update, Func<bool> checkpointCallback, int sequence = 1)
		{
			DataStreamImmediateWriter stream = new DataStreamImmediateWriter(this, cursor, dataRow, update, checkpointCallback, sequence);
			Stream parentStream = new PooledBufferedStream(stream, DataColumn.cachingWriterPool);
			return new CachingStream(parentStream, 32768);
		}

		public Stream OpenImmediateWriter(DataTableCursor cursor, DataRow dataRow, bool update, int sequence = 1)
		{
			DataStreamImmediateWriter stream = new DataStreamImmediateWriter(this, cursor, dataRow, update, null, sequence);
			return new PooledBufferedStream(stream, DataColumn.immediateWriterPool);
		}

		public ColumnValue GetColumnValueForRetrieval()
		{
			ColumnValue columnValue;
			switch (this.JetColType)
			{
			case JET_coltyp.Bit:
				columnValue = new BoolColumnValue();
				goto IL_E3;
			case JET_coltyp.UnsignedByte:
				columnValue = new ByteColumnValue();
				goto IL_E3;
			case JET_coltyp.Short:
				columnValue = new Int16ColumnValue();
				goto IL_E3;
			case JET_coltyp.Long:
				columnValue = new Int32ColumnValue();
				goto IL_E3;
			case JET_coltyp.Currency:
				columnValue = new Int64ColumnValue();
				goto IL_E3;
			case JET_coltyp.IEEESingle:
				columnValue = new FloatColumnValue();
				goto IL_E3;
			case JET_coltyp.IEEEDouble:
				columnValue = new BytesColumnValue();
				goto IL_E3;
			case JET_coltyp.DateTime:
				columnValue = new DateTimeColumnValue();
				goto IL_E3;
			case JET_coltyp.Binary:
			case JET_coltyp.LongBinary:
				columnValue = new BytesColumnValue();
				goto IL_E3;
			case JET_coltyp.Text:
			case JET_coltyp.LongText:
				columnValue = new StringColumnValue();
				goto IL_E3;
			case (JET_coltyp)14:
				columnValue = new UInt32ColumnValue();
				goto IL_E3;
			case (JET_coltyp)15:
				columnValue = new Int64ColumnValue();
				goto IL_E3;
			case (JET_coltyp)16:
				columnValue = new GuidColumnValue();
				goto IL_E3;
			case (JET_coltyp)17:
				columnValue = new UInt16ColumnValue();
				goto IL_E3;
			}
			throw new ArgumentException(string.Format("GetColumnValueForRetrieval called with unknown column type! {0}", this.JetColType));
			IL_E3:
			columnValue.Columnid = this.ColumnId;
			return columnValue;
		}

		internal abstract void ColumnValueToCache(ColumnValue data, ColumnCache cache);

		internal abstract byte[] BytesFromCache(ColumnCache cache);

		internal abstract ColumnCache NewCacheCell();

		internal byte[] BytesFromCursor(DataTableCursor cursor, bool retrieveCopy = false, int sequence = 1)
		{
			try
			{
				return Api.RetrieveColumn(cursor.Session, cursor.TableId, this.ColumnId, RetrieveColumnGrbit.RetrieveNull | (retrieveCopy ? RetrieveColumnGrbit.RetrieveCopy : RetrieveColumnGrbit.None), new JET_RETINFO
				{
					itagSequence = sequence
				});
			}
			catch (EsentErrorException ex)
			{
				if (!DataSource.HandleIsamException(ex, cursor.Connection.Source))
				{
					throw;
				}
			}
			return null;
		}

		internal int ReadBytesFromCursor(DataTableCursor cursor, bool retrieveCopy, int sequence, int offset, byte[] buffer, int count)
		{
			JET_RETINFO retinfo = new JET_RETINFO
			{
				ibLongValue = offset,
				itagSequence = sequence
			};
			int val = 0;
			try
			{
				Api.JetRetrieveColumn(cursor.Session, cursor.TableId, this.ColumnId, buffer, count, 0, out val, RetrieveColumnGrbit.RetrieveNull | (retrieveCopy ? RetrieveColumnGrbit.RetrieveCopy : RetrieveColumnGrbit.None), retinfo);
			}
			catch (EsentErrorException ex)
			{
				if (!DataSource.HandleIsamException(ex, cursor.Connection.Source))
				{
					throw;
				}
			}
			return Math.Min(count, val);
		}

		internal void CopyData(DataTableCursor cursorFrom, DataTableCursor cursorTo)
		{
			for (int i = 1; i <= this.GetValueCount(cursorFrom); i++)
			{
				if (this.Cached)
				{
					this.SaveToCursor(cursorTo, this.BytesFromCursor(cursorFrom, false, i), i, false, -1);
				}
				else
				{
					byte[] array = new byte[32768];
					int num = 0;
					int num2;
					do
					{
						num2 = this.ReadBytesFromCursor(cursorFrom, false, i, num, array, array.Length);
						this.SaveToCursor(cursorTo, array, i, true, num2);
						num += num2;
					}
					while (num2 == array.Length);
				}
			}
		}

		internal int GetValueCount(DataTableCursor cursor)
		{
			if (!this.MultiValued)
			{
				return 1;
			}
			JET_RETRIEVECOLUMN jet_RETRIEVECOLUMN = new JET_RETRIEVECOLUMN
			{
				columnid = this.columnId,
				itagSequence = 0
			};
			Api.JetRetrieveColumns(cursor.Session, cursor.TableId, new JET_RETRIEVECOLUMN[]
			{
				jet_RETRIEVECOLUMN
			}, 1);
			return jet_RETRIEVECOLUMN.itagSequence;
		}

		internal string StringFromCursor(DataTableCursor cursor)
		{
			try
			{
				return Api.RetrieveColumnAsString(cursor.Session, cursor.TableId, this.ColumnId);
			}
			catch (EsentErrorException ex)
			{
				if (!DataSource.HandleIsamException(ex, cursor.Connection.Source))
				{
					throw;
				}
			}
			return null;
		}

		internal long? Int64FromCursor(DataTableCursor cursor)
		{
			try
			{
				return Api.RetrieveColumnAsInt64(cursor.Session, cursor.TableId, this.ColumnId);
			}
			catch (EsentErrorException ex)
			{
				if (!DataSource.HandleIsamException(ex, cursor.Connection.Source))
				{
					throw;
				}
			}
			return null;
		}

		internal int? Int32FromCursor(DataTableCursor cursor)
		{
			return this.Int32FromCursor(cursor, RetrieveColumnGrbit.None);
		}

		internal int? Int32FromIndex(DataTableCursor cursor)
		{
			return this.Int32FromCursor(cursor, RetrieveColumnGrbit.RetrieveFromIndex);
		}

		internal byte? ByteFromIndex(DataTableCursor cursor)
		{
			return this.ByteFromCursor(cursor, RetrieveColumnGrbit.RetrieveFromIndex);
		}

		internal int? Int32FromBookmark(DataTableCursor cursor)
		{
			return this.Int32FromCursor(cursor, RetrieveColumnGrbit.RetrieveFromPrimaryBookmark);
		}

		internal bool? BoolFromCursor(DataTableCursor cursor)
		{
			try
			{
				return Api.RetrieveColumnAsBoolean(cursor.Session, cursor.TableId, this.ColumnId);
			}
			catch (EsentErrorException ex)
			{
				if (!DataSource.HandleIsamException(ex, cursor.Connection.Source))
				{
					throw;
				}
			}
			return null;
		}

		internal void SaveToCursor(DataTableCursor cursor, byte[] data, int sequence = 1, bool appendLV = false, int count = -1)
		{
			if (count == -1)
			{
				count = ((data == null) ? 0 : data.Length);
			}
			this.SaveToCursor(cursor, data, sequence, count, 0, appendLV ? SetColumnGrbit.AppendLV : SetColumnGrbit.None);
		}

		internal void SaveToCursor(DataTableCursor cursor, byte[] data, int sequence, int count, int offset, SetColumnGrbit grbit)
		{
			JET_SETINFO setinfo = new JET_SETINFO
			{
				ibLongValue = offset,
				itagSequence = sequence
			};
			if (this.IntrinsicLV)
			{
				grbit |= SetColumnGrbit.IntrinsicLV;
			}
			try
			{
				Api.JetSetColumn(cursor.Session, cursor.TableId, this.ColumnId, data, count, grbit, setinfo);
			}
			catch (EsentErrorException ex)
			{
				if (!DataSource.HandleIsamException(ex, cursor.Connection.Source))
				{
					throw;
				}
			}
		}

		private int? Int32FromCursor(DataTableCursor cursor, RetrieveColumnGrbit grbit)
		{
			try
			{
				return Api.RetrieveColumnAsInt32(cursor.Session, cursor.TableId, this.ColumnId, grbit);
			}
			catch (EsentErrorException ex)
			{
				if (!DataSource.HandleIsamException(ex, cursor.Connection.Source))
				{
					throw;
				}
			}
			return null;
		}

		private byte? ByteFromCursor(DataTableCursor cursor, RetrieveColumnGrbit grbit)
		{
			try
			{
				return Api.RetrieveColumnAsByte(cursor.Session, cursor.TableId, this.ColumnId, grbit);
			}
			catch (EsentErrorException ex)
			{
				if (!DataSource.HandleIsamException(ex, cursor.Connection.Source))
				{
					throw;
				}
			}
			return null;
		}

		private const int UnboundCacheIndex = -1;

		private static BufferPool cachingWriterPool = new BufferPool(DataStream.JetChunkSize, true);

		private static BufferPool immediateWriterPool = new BufferPool(DataStream.TransportChunkSize, true);

		private readonly JET_coltyp type;

		private readonly bool fixedSize = true;

		private string name;

		private bool required;

		private bool cached;

		private bool autoIncremented;

		private bool autoVersioned;

		private bool intrinsicLV;

		private bool multiValued;

		private int columnSize;

		private int cacheIndex = -1;

		private JET_COLUMNID columnId;
	}
}
